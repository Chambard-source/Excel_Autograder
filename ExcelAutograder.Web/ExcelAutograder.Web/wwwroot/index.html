<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Excel Autograder</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #121822;
            --muted: #1c2430;
            --ink: #e7ecf3;
            --ink2: #b8c0cc;
            --accent: #4aa3ff;
            /* max width the content should ever reach on large screens */
            --content-max: 1160px; /* tweak to taste */
            /* side padding that scales a bit with the viewport */
            --gutter: clamp(12px, 2vw, 24px);
        }

        html, body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial;
        }

        h1 {
            font-weight: 700;
            letter-spacing: .3px;
            margin: 18px 0;
        }

        * {
            box-sizing: border-box;
        }

        .wrap {
            max-width: var(--content-max);
            margin-inline: auto; /* center */
            padding-inline: var(--gutter);
            box-sizing: border-box;
        }

        /* ---------- Grid rows ---------- */
        .row {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: clamp(12px, 2vw, 24px);
        }

            /* TOP PAIR ONLY: enforce a visible gap and sane min width */
            .row.row-top {
                grid-template-columns: 1fr 1fr;
                gap: 10px !important; /* guaranteed gutter */
            }
                /* allow children to shrink rather than push across the gap */
                .row.row-top > * {
                    min-width: 0;
                }

        /* stack on smaller viewports */
        @media (max-width: 1024px) {
            .row {
                grid-template-columns: 1fr;
            }
        }

        /* ---------- Cards ---------- */
        .card {
            background: var(--panel);
            border: 1px solid var(--muted);
            border-radius: 10px;
            padding: 16px;
        }

        .card, .builder-card, #resultsCard {
            width: 100%;
            max-width: 100%;
            margin-inline: 0;
        }

        .stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .hstack {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        label small {
            color: var(--ink2);
        }

        input[type="text"], input[type="number"], textarea, select {
            background: #0e131b;
            border: 1px solid var(--muted);
            border-radius: 8px;
            color: var(--ink);
            padding: 8px 10px;
            outline: none;
            min-width: 0;
        }

        input[type="file"] {
            color: var(--ink2);
        }

        textarea {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            white-space: pre-wrap;
            overflow-wrap: anywhere;
            resize: vertical;
        }

        #jsonBox {
            width: 100%;
            min-height: clamp(160px, 24vh, 220px);
        }

        button {
            background: #1a2230;
            border: 1px solid #263041;
            color: var(--ink);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
        }

            button.primary {
                background: var(--accent);
                border-color: transparent;
                color: #06131f;
            }

            button.danger {
                background: #3b1a1a;
                border-color: #5b2a2a;
            }

            button.ghost {
                background: #0e131b;
            }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .sheet {
            border: 1px dashed #2b3748;
            border-radius: 10px;
            padding: 12px;
            margin-top: 12px;
        }

        .rule {
            border: 1px solid #2b3748;
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
            background: #0f1520;
        }

            /* FLEX layout for the first row */
            .rule .row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center; /* prevents tall stretch */
            }
                /* make inputs/selects same height as the icon buttons */
                .rule .row input[type="text"],
                .rule .row input[type="number"],
                .rule .row select {
                    height: 36px;
                    padding: 0 12px;
                    line-height: 36px;
                }

        /* small, uniform arrow buttons (you already added .btn-icon) */
        button.ghost.btn-icon {
            flex: 0 0 auto;
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            font-size: 16px;
            border-radius: 8px;
        }

        /* reserve a slim column for the arrows */
        .rule .row .arrows {
            flex: 0 0 44px;
        }

        /* Section width that grows but doesn’t explode */
        .rule .row .labelled.section {
            min-width: 260px;
            flex: 1 0 320px;
        }

        #jsonFilename {
            height: 36px;
            padding: 0 12px;
            line-height: 36px;
        }

        .builder-card {
            width: 100%;
        }

            .builder-card.collapsed #builderBody {
                display: none;
            }

        .hidden {
            display: none !important;
        }

        /* ---------- Table rule preview polish ---------- */
        .preview-card {
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 10px;
            background: #0b0b0f;
        }

        .preview-title {
            font-size: 12px;
            color: #9aa0a6;
            margin-bottom: 6px;
        }

        .chips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
            gap: 10px;
        }

        .chips-col .head {
            font-size: 12px;
            color: #b9c1c8;
            margin-bottom: 4px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .chip {
            font-size: 11px;
            padding: 2px 8px;
            border: 1px solid #2a2a2a;
            background: #11151a;
            border-radius: 999px;
            color: #d9dee3;
        }

        .scroll-wrap {
            max-height: 220px;
            overflow: auto;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
        }

        .mini-table {
            width: max-content;
            max-width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 12px;
        }

            .mini-table thead th {
                position: sticky;
                top: 0;
                background: #0f1216;
                color: #cbd3da;
                text-align: left;
                border-bottom: 1px solid #2a2a2a;
                padding: 6px 8px;
            }

            .mini-table tbody td {
                padding: 6px 8px;
                border-bottom: 1px dashed #1f2429;
                color: #e6eaee;
            }

            .mini-table tbody tr:nth-child(even) td {
                background: #0d1015;
            }

        .td-num {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .muted {
            color: #9aa0a6;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        }

        #resultsCard {
            width: 100%;
        }

        .section-row td {
            background: #0e151f;
            border-top: 2px solid #263041;
        }

        .tiny {
            font-size: 12px;
            color: var(--ink2);
        }

        .pill {
            padding: 2px 8px;
            border-radius: 999px;
            background: #1f2937;
            border: 1px solid #2a3647;
        }

        .spacer {
            height: 8px;
        }

        .right {
            margin-left: auto;
        }

        .hr {
            height: 1px;
            background: #223046;
            margin: 12px 0;
        }

        .checkbox {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            border: 1px solid #263041;
            padding: 6px 8px;
            vertical-align: top;
        }

        th {
            background: #0e151f;
            font-weight: 600;
        }

        .tag {
            display: inline-block;
            padding: 1px 8px;
            border-radius: 999px;
            font-size: 12px;
        }

        .pass {
            background: #103a22;
            border: 1px solid #1e6d42;
            color: #c8f7dc;
        }

        .fail {
            background: #3a1010;
            border: 1px solid #6d1e1e;
            color: #f7c8c8;
        }

        .partial {
            background: #3a290f;
            border: 1px solid #7a5a1a;
            color: #ffe0a6;
        }

        #resultsCard.only-misses [data-status="pass"] {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Excel Autograder</h1>

        <div class="row row-top">
            <div class="card stack">
                <div class="stack">
                    <label>Key workbook (.xlsx) <small>(used to generate rubric)</small></label>
                    <input type="file" id="keyFile" accept=".xlsx" />
                </div>

                <div class="stack">
                    <label>Student workbooks (.xlsx) — you can select multiple</label>
                    <input type="file" id="studentFiles" multiple accept=".xlsx" />
                </div>

                <div class="hstack">
                    <button id="btnGradeWithFile" class="ghost">Grade (using uploaded rubric file)</button>
                    <button id="btnGradeWithJson" class="primary">Grade with Current JSON</button>
                </div>
            </div>

            <div class="card stack">
                <div class="stack">
                    <label>Rubric (.json) <small>(optional — only used by “Grade (using uploaded rubric file)”)</small></label>
                    <input type="file" id="rubricFile" accept=".json" />
                </div>
                <div class="stack">
                    <label>Current Rubric JSON (preview)</label>
                    <textarea id="jsonBox" spellcheck="false"></textarea>
                    <div class="hstack" style="gap:10px; align-items:center;">
                        <input id="jsonFilename" placeholder="File name (e.g., HW_2_Rubric)" style="width:260px;">
                        <button id="btnDownloadJson" class="ghost">Download JSON</button>
                    </div>
                    <div class="tiny">This preview is always <strong>exactly</strong> what the builder below contains.</div>
                </div>
            </div>
        </div>

        <div class="spacer"></div>

        <div class="card builder-card">
            <h2 style="margin:4px 0 12px">Rubric Builder</h2>

            <!-- Collapsible header (sits just above the builder controls) -->
            <div class="hstack" style="justify-content:space-between;align-items:center;margin:6px 0 10px;">
                <div class="tiny muted">Builder controls</div>
                <button id="btnToggleBuilder" class="ghost">Hide builder</button>
            </div>

            <!-- Everything in the builder lives inside #builderBody so we can collapse it -->
            <div id="builderBody">
                <div class="grid-2">
                    <div class="stack">
                        <label>Generate from Key (uses the Key file chosen above)</label>
                        <div class="hstack">
                            <input id="sheetHint" type="text" placeholder="e.g., 'Scores' or 'Summary' (optional)" />
                            <label class="checkbox"><input type="checkbox" id="allSheets" /> All sheets</label>
                            <input id="totalPoints" type="number" step="0.25" min="0" placeholder="Total Points (e.g., 5 or 10)" style="width:180px" />
                            <button id="btnGenerate" class="primary">Generate</button>
                            <button id="btnClear" class="danger">Clear Builder</button>
                        </div>
                        <div class="tiny muted">Generate → replaces the builder entirely with the auto-rubric from your key. No merge, no leftovers.</div>
                    </div>

                    <div class="stack">
                        <label>Report options</label>
                        <div class="hstack">
                            <label class="checkbox"><input type="checkbox" id="optPassFail" checked /> Include Pass/Fail</label>
                            <label class="checkbox"><input type="checkbox" id="optComments" checked /> Include Comments</label>
                            <button id="btnGenerateJson" class="right">Generate JSON (from builder)</button>
                        </div>
                    </div>
                </div>

                <!-- keep the rest of your builder content (Add Sheet, sheets list, etc.) below, still inside #builderBody -->


                <div class="hr"></div>

                <div class="hstack">
                    <button id="btnAddSheet" class="ghost">+ Add Sheet</button>
                    <span class="tiny pill">Tip: use “Duplicate” to clone a whole sheet or a single rule.</span>
                </div>

                <div id="sheets" class="stack"></div>
            </div>

            <div class="spacer"></div>

            <!-- RESULTS -->
            <div class="card stack" id="resultsCard" style="display:none">
                <div class="hstack" style="align-items:center; justify-content:space-between;">
                    <h2 style="margin:0">Results</h2>
                    <div class="hstack" style="gap:12px; align-items:center;">
                        <!-- NEW -->
                        <label class="tiny hstack" style="gap:6px; cursor:pointer;">
                            <input id="toggleOnlyMisses" type="checkbox">
                            <span>Show only misses</span>
                        </label>
                        <button id="btnDownloadReport" class="ghost right" title="Download the raw report as JSON">Download report</button>
                    </div>
                </div>
                <div id="resultsBody"></div>
            </div>
        </div>
    </div>

    <script>
        // ---------- helpers
        const $ = s => document.querySelector(s);
        const el = (t, c, h) => { const e = document.createElement(t); if (c) e.className = c; if (h != null) e.innerHTML = h; return e; };
        const download = (name, text) => { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text], { type: 'application/json' })); a.download = name; a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 1000); };

        // --- PIVOT HELPERS (UI) ---
        function ensurePivot(r) {
            const p = r.pivot || {};
            // normalize arrays
            const arr = v => Array.isArray(v) ? v : (v ? [v] : []);
            // map PascalCase → camelCase if needed
            const pv = {
                sheet: p.sheet ?? p.Sheet ?? null,
                tableNameLike: p.tableNameLike ?? p.TableNameLike ?? null,
                rows: arr(p.rows ?? p.Rows).filter(Boolean),
                columns: arr(p.columns ?? p.Columns).filter(Boolean),
                filters: arr(p.filters ?? p.Filters).filter(Boolean),
                values: (p.values ?? p.Values ?? []).map(v => ({
                    field: v.field ?? v.Field ?? "",
                    agg: (v.agg ?? v.Agg ?? "sum").toLowerCase()
                }))
            };
            r.pivot = pv; // write back normalized shape so preview is clean
            return pv;
        }

        const splitCSV = s => (s || '').split(',').map(x => x.trim()).filter(Boolean);
        const joinCSV = arr => (arr || []).join(', ');

        function pivotValuesBlock(rule, onChange) {
            const pv = ensurePivot(rule);
            const wrap = el('div', 'stack');

            const list = el('div', 'stack');
            wrap.append(list);

            function oneRow(item, idx) {
                const row = el('div', 'hstack');
                const f = el('input'); f.placeholder = 'Field (e.g., Sales)'; f.style.width = '220px'; f.value = item.field || '';
                const agg = el('select');['sum', 'count', 'average', 'min', 'max'].forEach(a => { const o = el('option'); o.value = o.textContent = a; if ((item.agg || 'sum') === a) o.selected = true; agg.append(o); });
                const del = el('button', 'ghost danger', 'Remove');
                row.append(labelled(f, 'Field'), labelled(agg, 'Aggregation'), del);

                f.onchange = () => { pv.values[idx].field = f.value.trim(); onChange(); };
                agg.onchange = () => { pv.values[idx].agg = agg.value; onChange(); };
                del.onclick = () => { pv.values.splice(idx, 1); render(); };

                return row;
            }

            function refreshList() {
                list.innerHTML = '';
                pv.values.forEach((v, i) => list.append(oneRow(v, i)));
            }
            refreshList();

            const addBtn = el('button', 'ghost', '+ Add Value');
            addBtn.onclick = () => { pv.values.push({ field: '', agg: 'sum' }); refreshList(); onChange(); };
            wrap.append(addBtn);

            return wrap;
        }


        function ensureChart(r) {
            const c = r.chart || {};
            const norm = {
                sheet: c.sheet ?? null,
                name_like: c.name_like ?? null,
                type: c.type ?? null,            // line, column, bar, pie, scatter, area, doughnut, radar, bubble
                title: c.title ?? null,
                title_ref: c.title_ref ?? null,
                legend_pos: c.legend_pos ?? null, // t,r,b,l,tr
                data_labels: (typeof c.data_labels === 'boolean') ? c.data_labels : null,
                x_title: c.x_title ?? null,
                y_title: c.y_title ?? null,
                series: Array.isArray(c.series) ? c.series.map(s => ({
                    name: s?.name ?? null,
                    name_ref: s?.name_ref ?? null,
                    cat_ref: s?.cat_ref ?? null,
                    val_ref: s?.val_ref ?? null
                })) : []
            };
            r.chart = norm;   // write back normalized shape so preview is clean
            return norm;
        }

        function ensureTable(r) {
            const t = r.table || {};
            const norm = {
                sheet: t.sheet ?? null,
                name_like: t.name_like ?? null,
                columns: Array.isArray(t.columns) ? t.columns.filter(Boolean) : [],
                require_order: (typeof t.require_order === 'boolean') ? t.require_order : null
            };
            r.table = norm;
            return norm;
        }

        // ---------- builder state
        let rubric = { points: 5, report: { include_pass_fail_column: true, include_comments: true }, sheets: {} };
        const RULE_TYPES = ['value', 'formula', 'format', 'range_value', 'range_formula', 'range_format', 'custom_note', 'range_sequence', 'range_numeric', 'pivot_layout', 'conditional_format', 'chart', 'table'];
        const emptyRule = (type = 'formula') => ({ type, points: 1, cell: '', range: '', note: '', tolerance: null, any_of: null, expected_from_key: null, expected: null, expected_regex: null, expected_formula: null, allow_regex: null, expected_formula_regex: null, format: null, require: null, start: null, step: null, require_absolute: null });

        // ---------- render
        function render() {
            $('#optPassFail').checked = !(rubric.report && rubric.report.include_pass_fail_column === false);
            $('#optComments').checked = !(rubric.report && rubric.report.include_comments === false);
            $('#totalPoints').value = rubric.points ?? '';
            const host = $('#sheets'); host.innerHTML = '';
            Object.entries(rubric.sheets).forEach(([name, spec]) => host.appendChild(sheetBlock(name, spec)));
            refreshJsonPreview();
        }

        document.getElementById('rubricFile').addEventListener('change', async (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            try {
                const text = await f.text();
                const obj = JSON.parse(text);
                rubric = obj;                // <-- replace builder state
                render();                    // <-- redraw builder blocks
                refreshJsonPreview();        // <-- refresh preview textarea
            } catch (err) {
                alert('Invalid rubric JSON: ' + (err?.message || err));
            }
        });

        function downloadRubricJSON() {
            const base = (document.getElementById('jsonFilename')?.value.trim() || 'rubric')
                .replace(/\.(json)?$/i, '');
            const name = base + '.json';
            const blob = new Blob([JSON.stringify(collectRubric(), null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(a.href);
        }

        function sheetBlock(name, spec) {
            const wrap = el('div', 'sheet');
            const header = el('div', 'hstack');
            const nameInput = el('input'); nameInput.type = 'text'; nameInput.value = name; nameInput.style.width = '260px';
            const btnDup = el('button', 'ghost', 'Duplicate'); const btnDel = el('button', 'ghost danger', 'Remove');
            header.append(el('div', '', '<span class="tiny">Sheet name</span><br/>'), nameInput, btnDup, btnDel);
            wrap.append(header);
            const list = el('div', 'stack'); (spec.checks || []).forEach((r, i) => list.append(ruleBlock(spec, r, i))); wrap.append(list);
            const btnAdd = el('button', 'ghost', '+ Add Rule'); btnAdd.onclick = () => { spec.checks.push(emptyRule('formula')); render(); }; wrap.append(btnAdd);
            nameInput.onchange = () => { const newName = (nameInput.value || 'Sheet').trim(); if (newName !== name) { rubric.sheets[newName] = spec; delete rubric.sheets[name]; render(); } };
            btnDel.onclick = () => { delete rubric.sheets[name]; render(); };
            btnDup.onclick = () => { let base = name + ' Copy', i = 1, c = base; while (rubric.sheets[c]) c = `${base} ${++i}`; rubric.sheets[c] = JSON.parse(JSON.stringify(spec)); render(); };
            return wrap;
        }

        function ruleBlock(spec, r, idx) {
            const b = el('div', 'rule');
            const row1 = el('div', 'row');          // header row

            // --- controls you already create ---
            const typeSel = el('select');
            RULE_TYPES.forEach(t => {
                const o = el('option'); o.value = t; o.textContent = t;
                if (t === r.type) o.selected = true;
                typeSel.append(o);
            });
            const pts = el('input'); pts.type = 'number'; pts.step = '0.25'; pts.min = '0'; pts.value = r.points ?? 1;
            const cell = el('input'); cell.placeholder = 'e.g. B12'; cell.value = r.cell ?? '';
            const range = el('input'); range.placeholder = 'e.g. A2:B11'; range.value = r.range ?? '';
            const note = el('input'); note.placeholder = 'Note'; note.value = r.note ?? '';

            // gentle sizing so the row looks neat
            typeSel.style.minWidth = '160px';
            pts.style.width = '84px';
            cell.style.width = '140px';
            range.style.width = '220px';
            note.style.width = '240px';

            // Section
            const section = el('input');
            section.placeholder = 'Section (optional, e.g., SUMIFS)';
            section.value = r.section ?? '';
            section.onchange = () => { r.section = (section.value || '').trim() || null; refreshJsonPreview(); };
            const labelledSection = labelled(section, 'Section');
            labelledSection.classList.add('section');   // <- lets CSS size it

            // Move buttons
            const btnUp = el('button', 'ghost btn-icon', '▲');
            const btnDown = el('button', 'ghost btn-icon', '▼');
            btnUp.title = 'Move up'; btnDown.title = 'Move down';
            const arrows = el('div', 'arrows hstack');   // <- has the reserved width
            arrows.style.flexDirection = 'column';
            arrows.style.gap = '6px';
            arrows.append(btnUp, btnDown);

            btnUp.onclick = () => {
                if (idx > 0) { [spec.checks[idx - 1], spec.checks[idx]] = [spec.checks[idx], spec.checks[idx - 1]]; render(); }
            };
            btnDown.onclick = () => {
                if (idx < spec.checks.length - 1) { [spec.checks[idx + 1], spec.checks[idx]] = [spec.checks[idx], spec.checks[idx + 1]]; render(); }
            };

            // ✅ wrap Type in 'labelled' so sizing CSS applies
            row1.append(
                arrows,
                labelledSection,
                labelled(typeSel, 'Type'),
                labelled(pts, 'Pts'),
                labelled(cell, 'Cell'),
                labelled(range, 'Range')
                // (leave NOTE for row2 below to keep header compact)
            );
            b.append(row1);

            // Optional: put Note on its own row to avoid cramping the header
            const row2 = el('div', 'row');
            row2.append(labelled(note, 'Note'));
            b.append(row2);

            const exf = el('input'); exf.placeholder = 'Expected formula (=A1+...)'; exf.style.width = '220px'; exf.value = r.expected_formula ?? '';
            const regex = el('input'); regex.placeholder = 'Regex (optional)'; regex.style.width = '200px'; regex.value = r.expected_formula_regex ?? '';
            const fromKey = checkbox('From key', !!r.expected_from_key);
            const absReq = checkbox('Require absolute ($)', !!r.require_absolute);
            const numFmt = el('input'); numFmt.placeholder = 'Number format (e.g. 0.00)'; numFmt.style.width = '200px'; numFmt.value = (r.format && (r.format.number_format || r.format.NumberFormat)) || '';
            const start = el('input'); start.type = 'number'; start.placeholder = 'Start'; start.style.width = '90px'; start.value = r.start ?? '';
            const step = el('input'); step.type = 'number'; step.placeholder = 'Step'; step.style.width = '90px'; step.value = r.step ?? '';
            const btnDup = el('button', 'ghost', 'Duplicate'); const btnDel = el('button', 'ghost danger', 'Remove');

            // NEW: Pivot inputs
            const pvSheet = el('input'); pvSheet.placeholder = 'Sheet (optional)';
            const pvName = el('input'); pvName.placeholder = 'Pivot name contains (optional)';
            pvSheet.style.width = '200px'; pvName.style.width = '260px';

            const pvRows = el('input'); pvRows.placeholder = 'Rows, comma-separated';
            const pvCols = el('input'); pvCols.placeholder = 'Columns, comma-separated';
            const pvFil = el('input'); pvFil.placeholder = 'Filters, comma-separated';
            pvRows.style.width = pvCols.style.width = pvFil.style.width = '260px';

            const pvValuesUI = pivotValuesBlock(r, refreshJsonPreview);


            // ---------- Number-format UI helpers (kind <-> pattern) ----------

            const FMT_KIND_ORDER = [
                'general', 'number', 'currency', 'accounting', 'percent',
                'short_date', 'long_date', 'time', 'datetime', 'scientific', 'fraction', 'text', 'custom'
            ];

            function fmtPatternFrom(kind, decimals) {
                const d = Math.max(0, Number(decimals || 0));
                const dot = d > 0 ? '.' + '0'.repeat(d) : '';

                switch (kind) {
                    case 'general': return 'General';
                    case 'number': return '#,##0' + dot;
                    case 'currency': return '$#,##0' + dot;
                    case 'accounting': return '_($* #,##0' + dot + '_);_($* (#,##0' + dot + '_);_($* "-"??_);_(@_)';
                    case 'percent': return '0' + dot + '%';
                    case 'short_date': return 'm/d/yy';
                    case 'long_date': return 'mmmm d, yyyy';
                    case 'time': return 'h:mm AM/PM';
                    case 'datetime': return 'm/d/yy h:mm AM/PM';
                    case 'scientific': return '0' + (d > 0 ? ('.' + '0'.repeat(d)) : '.0') + 'E+00';
                    case 'fraction': return '# ?/?';
                    case 'text': return '@';
                    case 'custom': return ''; // user will type in the text box
                    default: return '';
                }
            }

            // Rough guesser to prefill dropdown/spinner from an existing pattern
            function guessKindAndDecimals(fmt) {
                const raw = (fmt || '').trim();
                const first = raw.split(';')[0];
                const lower = first.toLowerCase();

                const decs = (() => {
                    const m = /(?:^|;)[^;]*\.(0+)/.exec(first);
                    return m ? m[1].length : null;
                })();

                if (!raw || lower === 'general') return { kind: 'general', decimals: null, raw };
                if (lower.includes('%')) return { kind: 'percent', decimals: decs ?? 0, raw };
                if (lower.includes('_(') || lower.includes('* ') || (lower.includes('$') && lower.includes('_')))
                    return { kind: 'accounting', decimals: decs ?? 0, raw };
                if (/\$|€|£|¥|₩/.test(first)) return { kind: 'currency', decimals: decs ?? 2, raw };
                if (lower.includes('e+')) return { kind: 'scientific', decimals: decs ?? 1, raw };
                if (lower.includes('@')) return { kind: 'text', decimals: null, raw };
                if (lower.includes('?/')) return { kind: 'fraction', decimals: null, raw };
                const hasD = /d/.test(lower), hasM = /m/.test(lower), hasY = /y/.test(lower),
                    hasH = /h/.test(lower), hasS = /s/.test(lower), hasAM = lower.includes('am/pm');
                if ((hasD || hasM || hasY) && (hasH || hasS || hasAM)) return { kind: 'datetime', decimals: null, raw };
                if (hasH || hasS || hasAM) return { kind: 'time', decimals: null, raw };
                if (/(mmm|dddd)/i.test(first)) return { kind: 'long_date', decimals: null, raw };
                if (hasD || hasM || hasY) return { kind: 'short_date', decimals: null, raw };
                if (/[#0]/.test(first)) return { kind: 'number', decimals: decs ?? 0, raw };
                return { kind: 'custom', decimals: null, raw };
            }


            function showFor(type) {
                row2.innerHTML = '';

                // Replace the duplicate helper inside showFor(...) with this one:
                function hideCellAndRange() {
                    // Hide the generic Cell / Range wrappers (they're not used by some rule types)
                    const hide = inp => inp?.closest('.labelled')?.classList.add('hidden');
                    // search inside this rule block `b`
                    hide(b.querySelector('input[placeholder="e.g. B12"]'));
                    hide(b.querySelector('input[placeholder="e.g. A2:B11"]'));
                }

                function hideSeriesControls() {
                    // Hide any “Series (categories/values…) / + Add series” bits (meant for charts)
                    const seriesLabel = Array.from(row2.querySelectorAll('.tiny, .muted, div'))
                        .find(n => /Series \(categories\/values/i.test(n.textContent || ''));
                    if (seriesLabel) {
                        let p = seriesLabel.parentElement;
                        while (p && p !== row2) {
                            if (p.classList.contains('stack') || p.classList.contains('row')) {
                                p.classList.add('hidden');
                                break;
                            }
                            p = p.parentElement;
                        }
                    }
                }


                if (type === 'formula') {
                    row2.append(labelled(exf, 'Expected formula'), labelled(regex, 'Regex'), fromKey.wrap, absReq.wrap);

                    // --- Expected VALUE (of the evaluated formula) + absolute TOLERANCE ---
                    const expVal = el('input');
                    expVal.placeholder = 'e.g. 0.2154 or 21.54%';
                    expVal.style.width = '220px';
                    // r.expected may be a string/number/null; show it as text
                    expVal.value = (r.expected ?? '') + '';
                    expVal.onchange = () => {
                        const v = (expVal.value ?? '').trim();
                        // store as string or null; grader handles numeric/percent parsing
                        r.expected = v === '' ? null : v;
                        refreshJsonPreview();
                    };

                    const tol = el('input');
                    tol.type = 'number';
                    tol.step = 'any';
                    tol.placeholder = 'e.g. 0.0001';
                    tol.style.width = '140px';
                    tol.value = (r.tolerance ?? '');
                    tol.onchange = () => {
                        const v = (tol.value ?? '').trim();
                        r.tolerance = v === '' ? null : +v; // numeric or null
                        refreshJsonPreview();
                    };

                    // append the new controls to the same row as the formula fields
                    row2.append(labelled(expVal, 'Expected value'), labelled(tol, 'Tolerance (abs)'));

                    // --- "any_of" support for formulas ---
                    r.any_of = Array.isArray(r.any_of) ? r.any_of : [];

                    const list = el('div', 'stack');
                    function renderAnyOfFormula() {
                        list.innerHTML = '';
                        (r.any_of || []).forEach((opt, i) => {
                            const row = el('div', 'hstack');

                            const altF = el('input');
                            altF.placeholder = 'Alternative formula (=...)';
                            altF.style.width = '220px';
                            altF.value = opt.expected_formula ?? '';
                            altF.onchange = () => {
                                r.any_of[i].expected_formula = altF.value.trim() || null;
                                // if any alternatives exist, clear the single expected_formula
                                if ((r.any_of || []).length > 0) {
                                    r.expected_formula = null;
                                    exf.value = '';
                                }
                                refreshJsonPreview();
                            };

                            const altRe = el('input');
                            altRe.placeholder = 'Regex (optional)';
                            altRe.style.width = '200px';
                            altRe.value = opt.expected_formula_regex ?? '';
                            altRe.onchange = () => {
                                r.any_of[i].expected_formula_regex = altRe.value.trim() || null;
                                refreshJsonPreview();
                            };

                            const del = el('button', 'ghost danger', 'Remove');
                            del.onclick = () => {
                                r.any_of.splice(i, 1);
                                // if none left, allow the main expected_formula again (do not auto-fill)
                                if (r.any_of.length === 0) {
                                    r.expected_formula = (exf.value.trim() || null);
                                } else {
                                    r.expected_formula = null;
                                    exf.value = '';
                                }
                                renderAnyOfFormula();
                                refreshJsonPreview();
                            };

                            row.append(labelled(altF, 'Formula'), labelled(altRe, 'Regex'), del);
                            list.append(row);
                        });
                    }
                    renderAnyOfFormula();

                    const addAltF = el('button', 'ghost', 'Add formula');
                    addAltF.onclick = () => {
                        (r.any_of = r.any_of || []).push({ expected_formula: null, expected_formula_regex: null });
                        r.expected_formula = null;
                        exf.value = '';
                        renderAnyOfFormula();
                        refreshJsonPreview();
                    };

                    const anyWrap = el('div', 'stack');
                    anyWrap.append(el('div', 'tiny muted', 'Any of these formulas (optional):'), list, addAltF);

                    row2.append(anyWrap, btnDup, btnDel);
                } else if (type === 'value') {
                    // ---------- helpers ----------
                    const cast = v => (/^-?\d+(?:\.\d+)?$/.test(v) ? +v : v);
                    const clean = s => (s ?? '').trim();

                    // ensure structure
                    r.any_of = Array.isArray(r.any_of) ? r.any_of : [];

                    // ---------- main Expected (single only) ----------
                    const mainExp = el('input');
                    mainExp.placeholder = 'Expected (single value)';
                    mainExp.style.width = '260px';

                    // initialize from model
                    if ((r.any_of || []).length > 0) {
                        mainExp.value = '';          // multiple answers → expected must be null
                        r.expected = null;
                    } else {
                        mainExp.value = r.expected != null ? (r.expected + '') : '';
                    }

                    // rule-level case sensitivity (kept)
                    const csRule = document.createElement('input');
                    csRule.type = 'checkbox';
                    csRule.checked = !!r.case_sensitive;
                    csRule.onchange = () => { r.case_sensitive = csRule.checked; refreshJsonPreview(); };

                    // when user edits the single expected
                    mainExp.onchange = () => {
                        if ((r.any_of || []).length > 0) {
                            // multiple answers exist → keep expected=null and mirror UI
                            mainExp.value = '';
                            r.expected = null;
                        } else {
                            const v = clean(mainExp.value);
                            r.expected = v === '' ? null : cast(v);
                        }
                        refreshJsonPreview();
                    };

                    // ---------- any_of list (add/edit/remove) ----------
                    const list = el('div', 'stack');

                    function renderAnyOf() {
                        list.innerHTML = '';
                        (r.any_of || []).forEach((opt, i) => {
                            const row = el('div', 'hstack');

                            const exp = el('input');
                            exp.placeholder = 'Alternative expected value';
                            exp.style.width = '220px';
                            exp.value = opt.expected != null ? (opt.expected + '') : '';
                            exp.onchange = () => {
                                const v = clean(exp.value);
                                r.any_of[i].expected = v === '' ? null : cast(v);
                                r.expected = null;   // enforce: multiple answers → expected=null
                                mainExp.value = '';  // keep UI consistent
                                refreshJsonPreview();
                            };

                            const cs = document.createElement('input');
                            cs.type = 'checkbox';
                            cs.checked = !!opt.case_sensitive;
                            cs.onchange = () => { r.any_of[i].case_sensitive = cs.checked; refreshJsonPreview(); };

                            const del = el('button', 'ghost danger', 'Remove');
                            del.onclick = () => {
                                r.any_of.splice(i, 1);
                                if (r.any_of.length === 0) {
                                    // with none left, allow single expected again (do not auto-fill)
                                    r.expected = clean(mainExp.value) ? cast(mainExp.value) : null;
                                } else {
                                    r.expected = null; // still multiple → keep null
                                    mainExp.value = '';
                                }
                                renderAnyOf();
                                refreshJsonPreview();
                            };

                            row.append(labelled(exp, 'Answer'), labelled(cs, 'Case sensitive'), del);
                            list.append(row);
                        });
                    }

                    const addAlt = el('button', 'ghost', 'Add answer');
                    addAlt.onclick = () => {
                        (r.any_of = r.any_of || []).push({ expected: null });
                        r.expected = null;   // enforce shape
                        mainExp.value = '';  // single box disabled visually
                        renderAnyOf();
                        refreshJsonPreview();
                    };

                    // Duplicate / Remove rule (kept)
                    const btnDup = el('button', 'ghost', 'Duplicate');
                    const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };

                    // layout
                    const anyWrap = el('div', 'stack');
                    anyWrap.append(
                        el('div', 'tiny muted', 'Any of these answers (optional):'),
                        list,
                        addAlt
                    );

                    row2.append(
                        labelled(mainExp, 'Expected (single)'),
                        labelled(csRule, 'Case sensitive'),
                        anyWrap,
                        btnDup,
                        btnDel
                    );


                    renderAnyOf();
                    refreshJsonPreview();
                }

                else if (type === 'format' || type === 'range_format') {
                    r.format = r.format || {};
                    const getFmt = () => r.format.number_format || '';
                    const setFmt = v => { r.format.number_format = (v || '').trim() || null; refreshJsonPreview(); };

                    // ---------- Kind / Decimals / Pattern ----------
                    const kindSel = document.createElement('select');
                    [
                        ['general', 'General'],
                        ['number', 'Number'],
                        ['currency', 'Currency'],
                        ['accounting', 'Accounting'],
                        ['percent', 'Percent'],
                        ['short_date', 'Short date'],
                        ['long_date', 'Long date'],
                        ['time', 'Time'],
                        ['datetime', 'Date & time'],
                        ['scientific', 'Scientific'],
                        ['fraction', 'Fraction'],
                        ['text', 'Text'],
                        ['custom', 'Custom…']
                    ].forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; kindSel.append(o); });

                    const decWrap = document.createElement('div'); decWrap.className = 'stack';
                    const decInp = document.createElement('input');
                    decInp.type = 'number'; decInp.min = '0'; decInp.step = '1'; decInp.value = '2';
                    decWrap.append(decInp);

                    const numFmt = document.createElement('input');
                    numFmt.placeholder = 'e.g., $#,##0.00 or 0% or m/d/yy';
                    numFmt.style.width = '320px';

                    // Hydrate from existing pattern (guess kind + decimals)
                    const g = guessKindAndDecimals(getFmt());
                    kindSel.value = g.kind;
                    if (g.decimals != null) decInp.value = String(g.decimals);
                    numFmt.value = g.raw || fmtPatternFrom(kindSel.value, decInp.value);

                    const decimalsRelevant = k => ['number', 'currency', 'accounting', 'percent', 'scientific'].includes(k);

                    function refreshVisibility() {
                        decWrap.style.display = decimalsRelevant(kindSel.value) ? '' : 'none';
                        if (kindSel.value !== 'custom') {
                            numFmt.value = fmtPatternFrom(kindSel.value, decInp.value);
                            setFmt(numFmt.value);
                        }
                    }

                    kindSel.onchange = refreshVisibility;
                    decInp.onchange = refreshVisibility;
                    numFmt.onchange = () => {
                        const g2 = guessKindAndDecimals(numFmt.value);
                        setFmt(numFmt.value);
                        if (g2.kind && g2.kind !== kindSel.value) kindSel.value = g2.kind;
                        if (g2.decimals != null) decInp.value = String(g2.decimals);
                        refreshVisibility();
                    };

                    refreshVisibility();

                    // ---------- NEW: Bold & Font size ----------
                    // ensure nested object for compatibility
                    r.format.font = r.format.font || {};
                    // read (prefer nested, fallback to flat)
                    const initBold = (r.format.font.bold ?? r.format.font_bold) ?? null;
                    const initSize = (r.format.font.size ?? r.format.font_size) ?? null;

                    const boldCk = document.createElement('input');
                    boldCk.type = 'checkbox';
                    boldCk.checked = !!initBold;
                    boldCk.onchange = () => {
                        const v = boldCk.checked ? true : null;
                        r.format.font.bold = v;        // nested
                        r.format.font_bold = v;        // flat (BC)
                        refreshJsonPreview();
                    };

                    const sizeInp = document.createElement('input');
                    sizeInp.type = 'number';
                    sizeInp.min = '6'; sizeInp.max = '96'; sizeInp.step = '0.5';
                    sizeInp.placeholder = 'e.g., 12';
                    sizeInp.style.width = '120px';
                    sizeInp.value = (initSize ?? '').toString();
                    sizeInp.onchange = () => {
                        const t = sizeInp.value.trim();
                        const v = t === '' ? null : Number(t);
                        r.format.font.size = v;        // nested
                        r.format.font_size = v;        // flat (BC)
                        refreshJsonPreview();
                    };

                    // ---------- Layout ----------
                    // Row A: Kind | Decimals | Pattern
                    const rowA = el('div', 'row');
                    rowA.style.gridTemplateColumns = '1fr 0.5fr 1.2fr';
                    rowA.style.gap = '12px';
                    rowA.append(
                        labelled(kindSel, 'Kind'),
                        labelled(decWrap, 'Decimals'),
                        labelled(numFmt, 'Number format (A1 pattern)')
                    );

                    // Row B: Bold | Font size
                    const rowB = el('div', 'row');
                    rowB.style.gridTemplateColumns = '0.6fr 0.8fr';
                    rowB.style.gap = '12px';

                    const boldWrap = document.createElement('label');
                    boldWrap.className = 'checkbox';
                    boldWrap.append(boldCk, el('span', '', 'Bold'));

                    rowB.append(boldWrap, labelled(sizeInp, 'Font size (pt)'));

                    row2.append(rowA, rowB);

                    // Duplicate / Remove buttons
                    const btnDup = el('button', 'ghost', 'Duplicate');
                    const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);
                } else if (type === 'range_sequence') { row2.append(labelled(start, 'Start'), labelled(step, 'Step'), btnDup, btnDel); }
                else if (type === 'pivot_layout') {
                    const pv = ensurePivot(r);
                    pvSheet.value = pv.sheet ?? '';
                    pvName.value = pv.tableNameLike ?? '';
                    pvRows.value = joinCSV(pv.rows);
                    pvCols.value = joinCSV(pv.columns);
                    pvFil.value = joinCSV(pv.filters);

                    pvSheet.onchange = () => { ensurePivot(r).sheet = pvSheet.value.trim() || null; refreshJsonPreview(); };
                    pvName.onchange = () => { ensurePivot(r).tableNameLike = pvName.value.trim() || null; refreshJsonPreview(); };
                    pvRows.onchange = () => { ensurePivot(r).rows = splitCSV(pvRows.value); refreshJsonPreview(); };
                    pvCols.onchange = () => { ensurePivot(r).columns = splitCSV(pvCols.value); refreshJsonPreview(); };
                    pvFil.onchange = () => { ensurePivot(r).filters = splitCSV(pvFil.value); refreshJsonPreview(); };

                    const left = el('div', 'stack');
                    left.append(labelled(pvSheet, 'Sheet'), labelled(pvName, 'Name contains'), labelled(pvRows, 'Rows'), labelled(pvCols, 'Columns'), labelled(pvFil, 'Filters'));

                    const right = el('div', 'stack');
                    right.append(el('div', 'tiny muted', 'Values (Field + Aggregation)'), pvValuesUI);

                    // 2-column layout for pivot editor
                    const grid = el('div', 'row');
                    grid.style.gridTemplateColumns = '1fr 1fr';
                    grid.style.gap = '12px';
                    grid.append(left, right);

                    row2.append(grid);
                    const btnDup = el('button', 'ghost', 'Duplicate'); const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);
                } else if (type === 'conditional_format') {
                    // --- build basic labeled controls without depending on `labelled()` ---
                    const mkLabeled = (labelText, control) => {
                        const w = document.createElement('div');
                        w.className = 'stack';
                        const lab = document.createElement('div');
                        lab.className = 'tiny muted';
                        lab.textContent = labelText;
                        w.append(lab, control);
                        return w;
                    };

                    // controls
                    const sheet = document.createElement('input'); sheet.placeholder = 'Sheet (optional)';
                    const range = document.createElement('input'); range.placeholder = 'Range (e.g., B2:B50)';

                    const typ = document.createElement('select');
                    [['cellIs', 'Cell is…'], ['expression', 'Formula (TRUE/FALSE)'], ['containsText', 'Contains text'], ['top10', 'Top/bottom N'], ['dataBar', 'Data bar'], ['colorScale', 'Color scale'], ['iconSet', 'Icon set']]
                        .forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; typ.append(o); });

                    const op = document.createElement('select');  // OPERATOR
                    [['gt', '> greater than'], ['ge', '≥ greater than or equal'], ['lt', '< less than'], ['le', '≤ less than or equal'], ['eq', '= equal to'], ['ne', '≠ not equal to'], ['between', 'between (inclusive)'], ['notBetween', 'not between']]
                        .forEach(([v, l]) => { const o = document.createElement('option'); o.value = v; o.textContent = l; op.append(o); });

                    const f1 = document.createElement('input'); f1.placeholder = 'Value / Formula 1 (e.g., 85 or =B2>0)';
                    const f2 = document.createElement('input'); f2.placeholder = 'Value / Formula 2 (for between)';
                    const txt = document.createElement('input'); txt.placeholder = 'Text to look for';
                    const fill = document.createElement('input'); fill.placeholder = 'Fill RGB (optional, e.g., FFFF00)';

                    // hydrate rule state
                    r.cond = r.cond || {};
                    const c = r.cond;
                    sheet.value = c.sheet ?? '';
                    range.value = c.range ?? '';
                    typ.value = c.type ?? 'cellIs';
                    op.value = c.op ?? 'gt';
                    f1.value = c.formula1 ?? '';
                    f2.value = c.formula2 ?? '';
                    txt.value = c.text ?? '';
                    fill.value = c.fillRgb ?? '';

                    // ensure operator has a visible default
                    if (!op.value || ![...op.options].some(o => o.value === op.value)) {
                        op.selectedIndex = 0;   // first option (> greater than)
                    }


                    // layout rows
                    const topRow = document.createElement('div');
                    topRow.className = 'hstack';
                    topRow.style.gap = '8px';
                    topRow.style.flexWrap = 'wrap';

                    const wSheet = mkLabeled('Sheet', sheet);
                    const wRange = mkLabeled('Range', range);
                    const wType = mkLabeled('Type', typ);
                    const wOp = mkLabeled('Operator', op);   // explicit wrapper we toggle

                    topRow.append(wSheet, wRange, wType, wOp);
                    row2.append(topRow);

                    const botRow = document.createElement('div');
                    botRow.className = 'row';
                    botRow.style.gridTemplateColumns = '1fr 1fr 1fr 1fr';
                    botRow.style.gap = '8px';

                    const wF1 = mkLabeled('Value / Formula 1', f1);
                    const wF2 = mkLabeled('Value / Formula 2', f2);
                    const wText = mkLabeled('Text', txt);
                    const wFill = mkLabeled('Fill RGB', fill);

                    botRow.append(wF1, wF2, wText, wFill);
                    row2.append(botRow);

                    // actions
                    const btnDup = el('button', 'ghost', 'Duplicate');
                    const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);

                    // save + toggle
                    const save = () => {
                        const norm = s => (s || '').trim();
                        r.cond = {
                            sheet: norm(sheet.value) || null,
                            range: norm(range.value) || null,
                            type: typ.value || null,
                            op: op.value || null,
                            formula1: norm(f1.value) || null,
                            formula2: norm(f2.value) || null,
                            text: norm(txt.value) || null,
                            fillRgb: norm(fill.value) || null
                        };
                        refreshJsonPreview();
                        toggle();
                    };

                    const toggle = () => {
                        const t = typ.value;
                        // Operator visible only when "Cell is…"
                        wOp.style.display = (t === 'cellIs') ? '' : 'none';
                        // Value 2 only for between/notBetween under Cell is…
                        wF2.style.display = (t === 'cellIs' && (op.value === 'between' || op.value === 'notBetween')) ? '' : 'none';
                        // Text only for containsText
                        wText.style.display = (t === 'containsText') ? '' : 'none';
                        // Expression: operator + value2 hidden, value1 shown
                        if (t === 'expression') {
                            wOp.style.display = 'none';
                            wF2.style.display = 'none';
                        }
                        // Style-only types: hide op + value1 + value2 + text (fill may still be used)
                        if (t === 'dataBar' || t === 'colorScale' || t === 'iconSet' || t === 'top10') {
                            wOp.style.display = 'none';
                            wF1.style.display = 'none';
                            wF2.style.display = 'none';
                            wText.style.display = 'none';
                        }
                    };

                    [sheet, range, typ, op, f1, f2, txt, fill].forEach(x => x.addEventListener('change', save));

                    // IMPORTANT: call toggle AFTER appending to DOM so display changes take effect
                    toggle();
                } else if (type === 'chart') {
                    const ch = ensureChart(r);

                    // left column controls
                    const cSheet = el('input'); cSheet.placeholder = 'Sheet (optional)'; cSheet.style.width = '200px'; cSheet.value = ch.sheet ?? '';
                    const cName = el('input'); cName.placeholder = 'Chart name contains'; cName.style.width = '260px'; cName.value = ch.name_like ?? '';
                    const cType = el('select');['', 'column', 'bar', 'line', 'pie', 'pie3D', 'scatter', 'area', 'doughnut', 'radar', 'bubble']
                        .forEach(v => { const o = el('option'); o.value = v; o.textContent = v || '(any type)'; if ((ch.type || '') === v) o.selected = true; cType.append(o); });

                    const cTitle = el('input'); cTitle.placeholder = 'Title text (exact)'; cTitle.value = ch.title ?? '';
                    const cTitleRef = el('input'); cTitleRef.placeholder = 'Title from cell (e.g., Summary!$B$1)'; cTitleRef.value = ch.title_ref ?? '';
                    const cLegend = el('select');[['', '(any)'], ['t', 'top'], ['r', 'right'], ['b', 'bottom'], ['l', 'left'], ['tr', 'top-right']]
                        .forEach(([v, l]) => { const o = el('option'); o.value = v; o.textContent = l; if ((ch.legend_pos || '') === v) o.selected = true; cLegend.append(o); });
                    const cLabels = document.createElement('input'); cLabels.type = 'checkbox'; cLabels.checked = ch.data_labels === true;
                    const cX = el('input'); cX.placeholder = 'X-axis title'; cX.value = ch.x_title ?? '';
                    const cY = el('input'); cY.placeholder = 'Y-axis title'; cY.value = ch.y_title ?? '';

                    // series editor
                    const seriesWrap = el('div', 'stack');
                    function renderSeries() {
                        seriesWrap.innerHTML = '';
                        (ch.series || []).forEach((s, i) => {
                            const row = el('div', 'hstack');
                            const sName = el('input'); sName.placeholder = 'Series name (text)'; sName.style.width = '180px'; sName.value = s.name ?? '';
                            const sNameRef = el('input'); sNameRef.placeholder = 'Series name ref (e.g., Sheet!$B$1)'; sNameRef.style.width = '200px'; sNameRef.value = s.name_ref ?? '';
                            const sCat = el('input'); sCat.placeholder = 'Categories ref (e.g., Sheet!$A$2:$A$13)'; sCat.style.width = '260px'; sCat.value = s.cat_ref ?? '';
                            const sVal = el('input'); sVal.placeholder = 'Values ref (e.g., Sheet!$B$2:$B$13)'; sVal.style.width = '260px'; sVal.value = s.val_ref ?? '';
                            const del = el('button', 'ghost danger', 'Remove');

                            sName.onchange = () => { ch.series[i].name = sName.value.trim() || null; refreshJsonPreview(); };
                            sNameRef.onchange = () => { ch.series[i].name_ref = sNameRef.value.trim() || null; refreshJsonPreview(); };
                            sCat.onchange = () => { ch.series[i].cat_ref = sCat.value.trim() || null; refreshJsonPreview(); };
                            sVal.onchange = () => { ch.series[i].val_ref = sVal.value.trim() || null; refreshJsonPreview(); };
                            del.onclick = () => { ch.series.splice(i, 1); renderSeries(); refreshJsonPreview(); };

                            row.append(labelled(sName, 'Name'), labelled(sNameRef, 'Name ref'), labelled(sCat, 'Categories'), labelled(sVal, 'Values'), del);
                            seriesWrap.append(row);
                        });
                    }
                    renderSeries();

                    const addSeries = el('button', 'ghost', '+ Add series');
                    addSeries.onclick = () => { (ch.series = ch.series || []).push({ name: null, name_ref: null, cat_ref: null, val_ref: null }); renderSeries(); refreshJsonPreview(); };

                    // save handlers
                    cSheet.onchange = () => { ch.sheet = cSheet.value.trim() || null; refreshJsonPreview(); };
                    cName.onchange = () => { ch.name_like = cName.value.trim() || null; refreshJsonPreview(); };
                    cType.onchange = () => { ch.type = cType.value || null; refreshJsonPreview(); };
                    cTitle.onchange = () => { ch.title = cTitle.value.trim() || null; refreshJsonPreview(); };
                    cTitleRef.onchange = () => { ch.title_ref = cTitleRef.value.trim() || null; refreshJsonPreview(); };
                    cLegend.onchange = () => { ch.legend_pos = cLegend.value || null; refreshJsonPreview(); };
                    cLabels.onchange = () => { ch.data_labels = cLabels.checked ? true : null; refreshJsonPreview(); };
                    cX.onchange = () => { ch.x_title = cX.value.trim() || null; refreshJsonPreview(); };
                    cY.onchange = () => { ch.y_title = cY.value.trim() || null; refreshJsonPreview(); };

                    // layout (two columns to keep it neat)
                    const left = el('div', 'stack');
                    left.append(
                        labelled(cSheet, 'Sheet'),
                        labelled(cName, 'Name contains'),
                        labelled(cType, 'Chart type'),
                        labelled(cLegend, 'Legend position'),
                        labelled(cLabels, 'Data labels')
                    );

                    const right = el('div', 'stack');
                    right.append(
                        labelled(cTitle, 'Title'),
                        labelled(cTitleRef, 'Title (from cell)'),
                        labelled(cX, 'X-axis title'),
                        labelled(cY, 'Y-axis title')
                    );

                    const grid = el('div', 'row');
                    grid.style.gridTemplateColumns = '1fr 1fr';
                    grid.style.gap = '12px';
                    grid.append(left, right);

                    row2.append(grid);
                    b.append(row2, el('div', 'tiny muted', 'Series (categories/values required for each):'), seriesWrap, addSeries);

                    // Duplicate / Remove buttons
                    const btnDup = el('button', 'ghost', 'Duplicate');
                    const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);
                } else if (type === 'table') {
                    const t = ensureTable(r);

                    // Hide generic inputs that don't apply to tables
                    hideCellAndRange();
                    hideSeriesControls();

                    // ---------- Helpers ----------
                    const NUM_RE = /^\s*[$€£]?\s*-?\d{1,3}(?:,\d{3})*(?:\.\d+)?\s*%?\s*$/;

                    // ---------- Top: range + dims + allow extras ----------
                    const rangeRef = el('input'); rangeRef.placeholder = 'A1:D20 or Sheet!A1:D20';
                    rangeRef.value = t.range_ref || '';
                    rangeRef.onchange = () => { t.range_ref = rangeRef.value.trim() || null; refreshJsonPreview(); };

                    const rowsInp = el('input'); rowsInp.type = 'number'; rowsInp.min = '0';
                    rowsInp.placeholder = 'rows';
                    rowsInp.value = (t.rows ?? '').toString();
                    rowsInp.onchange = () => { const v = rowsInp.value.trim(); t.rows = v === '' ? null : Number(v); refreshJsonPreview(); };

                    const colsInp = el('input'); colsInp.type = 'number'; colsInp.min = '0';
                    colsInp.placeholder = 'cols';
                    colsInp.value = (t.cols ?? '').toString();
                    colsInp.onchange = () => { const v = colsInp.value.trim(); t.cols = v === '' ? null : Number(v); refreshJsonPreview(); };

                    const allowER = document.createElement('input'); allowER.type = 'checkbox';
                    allowER.checked = t.allow_extra_rows === true;
                    allowER.onchange = () => { t.allow_extra_rows = allowER.checked ? true : null; refreshJsonPreview(); };
                    const allowERLbl = el('label', 'checkbox'); allowERLbl.append(allowER, el('span', '', 'Allow extra rows'));

                    const allowEC = document.createElement('input'); allowEC.type = 'checkbox';
                    allowEC.checked = t.allow_extra_cols === true;
                    allowEC.onchange = () => { t.allow_extra_cols = allowEC.checked ? true : null; refreshJsonPreview(); };
                    const allowECLbl = el('label', 'checkbox'); allowECLbl.append(allowEC, el('span', '', 'Allow extra cols'));

                    const dims = el('div', 'row');
                    dims.style.gridTemplateColumns = '1.2fr .6fr .6fr .8fr .9fr';
                    dims.style.gap = '12px';
                    dims.append(labelled(rangeRef, 'Range (optional)'), labelled(rowsInp, 'Rows'), labelled(colsInp, 'Cols'), allowERLbl, allowECLbl);
                    row2.append(dims);

                    // ---------- Whole-body match toggles ----------
                    const matchWhole = document.createElement('input'); matchWhole.type = 'checkbox';
                    const orderMatters = document.createElement('input'); orderMatters.type = 'checkbox';
                    const caseSens = document.createElement('input'); caseSens.type = 'checkbox';
                    const trimCells = document.createElement('input'); trimCells.type = 'checkbox';

                    matchWhole.checked = !!t.body_match;
                    orderMatters.checked = !!t.body_order_matters;
                    caseSens.checked = !!t.body_case_sensitive;
                    trimCells.checked = (t.body_trim ?? true);

                    matchWhole.onchange = () => { t.body_match = matchWhole.checked ? true : null; refreshJsonPreview(); };
                    orderMatters.onchange = () => { t.body_order_matters = orderMatters.checked ? true : null; refreshJsonPreview(); };
                    caseSens.onchange = () => { t.body_case_sensitive = caseSens.checked ? true : null; refreshJsonPreview(); };
                    trimCells.onchange = () => { t.body_trim = trimCells.checked ? true : null; refreshJsonPreview(); };

                    const toggles = el('div', 'row');
                    toggles.style.gridTemplateColumns = 'auto auto auto auto';
                    toggles.style.gap = '14px';
                    toggles.append(
                        el('label', 'checkbox', null).appendChild(matchWhole).parentElement.appendChild(el('span', '', 'Match entire contents')).parentElement,
                        el('label', 'checkbox', null).appendChild(orderMatters).parentElement.appendChild(el('span', '', 'Row order matters')).parentElement,
                        el('label', 'checkbox', null).appendChild(caseSens).parentElement.appendChild(el('span', '', 'Case sensitive')).parentElement,
                        el('label', 'checkbox', null).appendChild(trimCells).parentElement.appendChild(el('span', '', 'Trim cell text')).parentElement
                    );
                    row2.append(toggles);

                    // ---------- Required rows (subset) ----------
                    const containsWrap = el('div', 'stack');
                    const list = el('div', 'stack');
                    function renderContains() {
                        list.innerHTML = '';
                        (t.contains_rows || []).forEach((obj, i) => {
                            const row = el('div', 'hstack');
                            const preview = el('div'); preview.className = 'mono small muted';
                            preview.textContent = Object.entries(obj).map(([k, v]) => `${k}="${v}"`).join('  ·  ');
                            const del = el('button', 'ghost danger', 'Remove');
                            del.onclick = () => { t.contains_rows.splice(i, 1); renderContains(); refreshJsonPreview(); };
                            row.append(preview, del);
                            list.append(row);
                        });
                    }
                    const pasteRows = el('button', 'ghost', 'Paste required rows…');
                    pasteRows.onclick = () => {
                        const txt = prompt(
                            'Paste CSV/TSV with headers in first row.\n' +
                            'Only the columns you include will be matched.\n' +
                            'Example:\nRegion,Item\nEast,Widgets\nWest,Gadgets', ''
                        );
                        if (txt != null) {
                            const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                            if (lines.length > 1) {
                                const delim = (txt.indexOf('\t') >= 0) ? '\t' : ',';
                                const headers = lines[0].split(delim).map(s => s.trim()).filter(Boolean);
                                const rows = lines.slice(1).map(line => line.split(delim));
                                t.contains_rows = rows.map(vals => {
                                    const obj = {};
                                    headers.forEach((h, i) => { if (vals[i] != null && vals[i].trim() !== '') obj[h] = vals[i].trim(); });
                                    return obj;
                                }).filter(o => Object.keys(o).length > 0);
                                renderContains();
                                refreshJsonPreview();
                            }
                        }
                    };
                    containsWrap.append(el('div', 'tiny muted', 'Required rows (must appear at least once):'), list, pasteRows);
                    row2.append(containsWrap);
                    renderContains();

                    // ---------- Columns editor ----------
                    t.columns = Array.isArray(t.columns) ? t.columns.filter(Boolean) : [];
                    const colList = el('div', 'stack');

                    function renderColumns() {
                        colList.innerHTML = '';
                        (t.columns || []).forEach((name, i) => {
                            const rrow = el('div', 'hstack');

                            const inp = el('input');
                            inp.placeholder = 'Header name';
                            inp.style.width = '260px';
                            inp.value = name || '';
                            inp.onchange = () => { t.columns[i] = inp.value.trim(); refreshJsonPreview(); };

                            const up = el('button', 'ghost', '↑');
                            up.onclick = () => {
                                if (i > 0) { [t.columns[i - 1], t.columns[i]] = [t.columns[i], t.columns[i - 1]]; renderColumns(); refreshJsonPreview(); }
                            };
                            const dn = el('button', 'ghost', '↓');
                            dn.onclick = () => {
                                if (i < t.columns.length - 1) { [t.columns[i + 1], t.columns[i]] = [t.columns[i], t.columns[i + 1]]; renderColumns(); refreshJsonPreview(); }
                            };
                            const del = el('button', 'ghost danger', 'Remove');
                            del.onclick = () => { t.columns.splice(i, 1); renderColumns(); refreshJsonPreview(); };

                            rrow.append(labelled(inp, `Header ${i + 1}`), up, dn, del);
                            colList.append(rrow);
                        });
                    }

                    const addCol = el('button', 'ghost', 'Add column');
                    addCol.onclick = () => { (t.columns = t.columns || []).push(''); renderColumns(); refreshJsonPreview(); };

                    const bulk = el('button', 'ghost', 'Paste…');
                    bulk.onclick = () => {
                        const txt = prompt('Paste header names (comma or newline separated):', '');
                        if (txt != null) {
                            const parts = txt.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
                            if (parts.length) { t.columns = parts; renderColumns(); refreshJsonPreview(); }
                        }
                    };

                    const reqOrder = document.createElement('input'); reqOrder.type = 'checkbox';
                    reqOrder.checked = t.require_order === true;
                    reqOrder.onchange = () => { t.require_order = reqOrder.checked; refreshJsonPreview(); };
                    const reqOrderLbl = el('label', 'checkbox'); reqOrderLbl.append(reqOrder, el('span', '', 'Require header order'));

                    const colsWrap = el('div', 'stack');
                    const colsLabel = el('div', 'tiny muted', 'Columns (in order if "Require header order" is checked):');
                    const actions = el('div', 'hstack'); actions.append(addCol, bulk);
                    colsWrap.append(colsLabel, colList, actions);

                    // Name like
                    const nameLike = el('input');
                    nameLike.placeholder = 'Table name contains (optional)';
                    nameLike.value = t.name_like || '';
                    nameLike.onchange = () => { t.name_like = nameLike.value.trim() || null; refreshJsonPreview(); };

                    // ---------- 2-column layout: columns editor (left) | preview (right) ----------
                    const left = el('div', 'stack');
                    left.append(labelled(nameLike, 'Name like'), colsWrap, reqOrderLbl);

                    const right = el('div', 'stack');
                    // preview toggle + panel
                    const show = document.createElement('input'); show.type = 'checkbox';
                    const showLbl = el('label', 'checkbox'); showLbl.append(show, el('span', '', 'Show key table data'));
                    const previewPanel = el('div', 'preview-card'); previewPanel.style.display = 'none';
                    right.append(showLbl, previewPanel);

                    show.onchange = () => {
                        previewPanel.style.display = show.checked ? '' : 'none';
                        if (show.checked) renderPreview();
                    };

                    function renderPreview() {
                        previewPanel.innerHTML = '';

                        const rows = Array.isArray(t.body_rows) ? t.body_rows : null;
                        const headers = Array.isArray(t.columns) ? t.columns : null;

                        if (!rows || !rows.length || !headers || !headers.length) {
                            previewPanel.append(el('div', 'muted', 'No captured table data.'));
                            return;
                        }

                        // Distinct chips
                        const chipsTitle = el('div', 'preview-title', 'Distinct values by column (sample up to 12):');
                        const chipsGrid = el('div', 'chips-grid');

                        headers.forEach((h, ci) => {
                            const uniq = new Map();
                            rows.forEach(r => { const v = (r[ci] ?? '').toString(); uniq.set(v, (uniq.get(v) || 0) + 1); });

                            const col = el('div', 'chips-col');
                            const head = el('div', 'head', h);
                            const chips = el('div', 'chips');
                            [...uniq.keys()].slice(0, 12).forEach(v => chips.append(Object.assign(el('span', 'chip'), { textContent: v === '' ? '(blank)' : v })));
                            if (uniq.size > 12) chips.append(Object.assign(el('span', 'chip'), { textContent: `+${uniq.size - 12} more` }));
                            col.append(head, chips);
                            chipsGrid.append(col);
                        });

                        // Data grid
                        const N = 25;
                        const gridTitle = el('div', 'preview-title', `Previewing first ${Math.min(N, rows.length)} of ${rows.length} data rows:`);
                        const tbl = document.createElement('table'); tbl.className = 'mini-table';
                        const thead = document.createElement('thead'); const trh = document.createElement('tr');
                        headers.forEach(h => { const th = document.createElement('th'); th.textContent = h; trh.append(th); });
                        thead.append(trh); tbl.append(thead);

                        const tbody = document.createElement('tbody');
                        rows.slice(0, N).forEach(r => {
                            const tr = document.createElement('tr');
                            headers.forEach((_, ci) => {
                                const td = document.createElement('td');
                                const text = (r[ci] ?? '').toString();
                                td.textContent = text;
                                if (NUM_RE.test(text)) td.classList.add('td-num');
                                tr.append(td);
                            });
                            tbody.append(tr);
                        });
                        tbl.append(tbody);

                        const scroll = el('div', 'scroll-wrap'); scroll.append(tbl);

                        previewPanel.append(chipsTitle, chipsGrid, gridTitle, scroll);
                    }

                    const grid = el('div', 'row'); grid.style.gridTemplateColumns = '1fr 1fr'; grid.style.gap = '16px';
                    grid.append(left, right);
                    row2.append(grid);

                    // ---------- Duplicate / Remove ----------
                    const btnDup = el('button', 'ghost', 'Duplicate');
                    const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);

                    // initial paint
                    renderColumns();
                } else {
                    // fallback
                    const btnDup = el('button', 'ghost', 'Duplicate'); const btnDel = el('button', 'ghost danger', 'Remove');
                    btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
                    btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
                    row2.append(btnDup, btnDel);
                }
            }

            showFor(r.type); b.append(row2);

            typeSel.onchange = () => { r.type = typeSel.value; showFor(r.type); refreshJsonPreview(); };
            pts.onchange = () => { r.points = +pts.value || 0; refreshJsonPreview(); };
            cell.onchange = () => { r.cell = cell.value.trim() || null; refreshJsonPreview(); };
            range.onchange = () => { r.range = range.value.trim() || null; refreshJsonPreview(); };
            note.onchange = () => { r.note = note.value.trim() || null; refreshJsonPreview(); };
            exf.onchange = () => { r.expected_formula = exf.value.trim() || null; refreshJsonPreview(); };
            regex.onchange = () => { r.expected_formula_regex = regex.value.trim() || null; refreshJsonPreview(); };
            fromKey.input.onchange = () => { r.expected_from_key = fromKey.input.checked ? true : null; refreshJsonPreview(); };
            absReq.input.onchange = () => { r.require_absolute = absReq.input.checked ? true : null; refreshJsonPreview(); };
            numFmt.onchange = () => { if (!r.format) r.format = {}; r.format.number_format = numFmt.value.trim() || null; refreshJsonPreview(); };
            start.onchange = () => { r.start = start.value === '' ? null : +start.value; refreshJsonPreview(); };
            step.onchange = () => { r.step = step.value === '' ? null : +step.value; refreshJsonPreview(); };
            btnDel.onclick = () => { spec.checks.splice(idx, 1); render(); };
            btnDup.onclick = () => { spec.checks.splice(idx + 1, 0, JSON.parse(JSON.stringify(r))); render(); };
            return b;
        }


        function labelled(input, label) {
            const box = el('div', 'stack labelled');  // <-- add labelled
            box.append(el('div', 'tiny muted', label), input);
            return box;
        }
        function checkbox(txt, checked) { const w = el('label', 'checkbox'); const c = el('input'); c.type = 'checkbox'; c.checked = checked; const s = el('span', '', txt); w.append(c, s); return { wrap: w, input: c }; }

        // ---------- JSON <-> builder
        function refreshJsonPreview() { $('#jsonBox').value = JSON.stringify(collectRubric(), null, 2); }
        function collectRubric() {
            rubric.points = +($('#totalPoints').value || rubric.points || 0) || 0;
            rubric.report = { include_pass_fail_column: $('#optPassFail').checked, include_comments: $('#optComments').checked };
            return rubric;
        }
        function loadRubric(json) {
            rubric = { points: json.points ?? 5, report: json.report ?? { include_pass_fail_column: true, include_comments: true }, sheets: {} };
            if (json.sheets) { for (const [name, spec] of Object.entries(json.sheets)) { rubric.sheets[name] = { checks: Array.isArray(spec.checks) ? spec.checks : [] }; } }
            render();
        }

        function ensureTable(r) {
            const t = r.table || {};
            r.table = {
                sheet: t.sheet ?? null,
                name_like: t.name_like ?? null,
                columns: Array.isArray(t.columns) ? t.columns.filter(Boolean) : [],
                require_order: (typeof t.require_order === 'boolean') ? t.require_order : null,

                range_ref: t.range_ref ?? null,
                rows: (typeof t.rows === 'number') ? t.rows : (t.rows ? Number(t.rows) : null),
                cols: (typeof t.cols === 'number') ? t.cols : (t.cols ? Number(t.cols) : null),
                allow_extra_rows: (typeof t.allow_extra_rows === 'boolean') ? t.allow_extra_rows : (t.allow_extra_rows ? true : null),
                allow_extra_cols: (typeof t.allow_extra_cols === 'boolean') ? t.allow_extra_cols : (t.allow_extra_cols ? true : null),
                contains_rows: Array.isArray(t.contains_rows) ? t.contains_rows : [],

                // NEW body match options + captured body
                body_match: (typeof t.body_match === 'boolean') ? t.body_match : (t.body_rows ? true : null),
                body_order_matters: (typeof t.body_order_matters === 'boolean') ? t.body_order_matters : null,
                body_case_sensitive: (typeof t.body_case_sensitive === 'boolean') ? t.body_case_sensitive : null,
                body_trim: (typeof t.body_trim === 'boolean') ? t.body_trim : true,
                body_rows: Array.isArray(t.body_rows) ? t.body_rows : null
            };
            return r.table;
        }

        // ---------- actions
        $('#btnAddSheet').onclick = () => { let base = 'Sheet', i = 1, name = base; while (rubric.sheets[name]) name = base + ' ' + (++i); rubric.sheets[name] = { checks: [emptyRule('formula')] }; render(); };
        $('#btnClear').onclick = () => { rubric = { points: +($('#totalPoints').value || 5), report: { include_pass_fail_column: $('#optPassFail').checked, include_comments: $('#optComments').checked }, sheets: {} }; render(); };
        $('#btnGenerateJson').onclick = () => { $('#jsonBox').value = JSON.stringify(collectRubric(), null, 2); };
        document.getElementById('btnDownloadJson')
            ?.addEventListener('click', (e) => {
                e.preventDefault();
                downloadRubricJSON();
            });

        // --- Rubric Builder collapse/expand ---
        const builderCard = document.querySelector('.builder-card') || document.getElementById('builderBody')?.closest('.card');
        const builderBody = document.getElementById('builderBody');
        const builderToggle = document.getElementById('btnToggleBuilder');

        function setBuilderCollapsed(on) {
            if (!builderBody) return;
            // Prefer toggling on the card if present; fall back to inlining a style
            builderCard?.classList.toggle('collapsed', !!on);
            if (!builderCard) builderBody.style.display = on ? 'none' : '';
            if (builderToggle) builderToggle.textContent = on ? 'Show builder' : 'Hide builder';
            try { localStorage.setItem('builderCollapsed', on ? '1' : '0'); } catch { }
        }

        // init from saved preference
        setBuilderCollapsed((localStorage.getItem('builderCollapsed') === '1'));

        // click handler
        builderToggle?.addEventListener('click', (e) => {
            e.preventDefault();
            const next = builderCard ? !builderCard.classList.contains('collapsed') : (builderBody.style.display !== 'none');
            setBuilderCollapsed(next);
        });


        // Auto-rubric from key
        async function generateFromKey() {
            const keyInput = $('#keyFile');
            const hint = ($('#sheetHint')?.value || '').trim();
            const allSheets = !!$('#allSheets')?.checked;
            const totalStr = ($('#totalPoints')?.value || '').trim();
            if (!keyInput?.files?.length) { alert('Please choose a key workbook first.'); return; }

            const key = keyInput.files[0];
            const url = `/api/auto-rubric`;
            const form = new FormData();
            form.append('key', key);
            if (hint) form.append('sheet', hint);         // <-- server expects 'sheet'
            form.append('all', allSheets ? 'true' : 'false'); // <-- server expects 'all'
            if (totalStr) form.append('total', totalStr);  // <-- server expects 'total'

            try {
                const res = await fetch(url, { method: 'POST', body: form });
                if (!res.ok) { const t = await res.text(); throw new Error(t || `HTTP ${res.status}`); }
                const rub = await res.json();
                $('#jsonBox').value = JSON.stringify(rub, null, 2);
                rubric = rub; // reset builder to server rubric
                render();
            } catch (err) {
                console.error(err);
                const msg = (err && err.message) ? err.message : String(err ?? 'unknown error');
                alert('Generation failed: ' + msg);
            }
        }
        $('#btnGenerate').addEventListener('click', e => { e.preventDefault(); generateFromKey(); });

        // ---------- grading
        $('#btnGradeWithFile').onclick = async () => {
            try {
                const key = $('#keyFile').files[0];
                const rub = $('#rubricFile').files[0];
                const studs = $('#studentFiles').files;
                if (!key || !rub || !studs.length) {
                    alert('Pick a key, a rubric file, and at least one student workbook.');
                    return;
                }

                const fd = new FormData();
                fd.append('key', key);
                fd.append('rubric', rub);
                for (const f of studs) fd.append('students', f);

                const res = await fetch('/api/grade', { method: 'POST', body: fd });
                const txt = await res.text();
                if (!res.ok) { alert(txt || `HTTP ${res.status}`); return; }   // << important
                showReport(txt);
            } catch (err) { console.error(err); alert('Grade failed'); }
        };

        $('#btnGradeWithJson').onclick = async () => {
            try {
                const key = $('#keyFile').files[0];
                const studs = $('#studentFiles').files;
                if (!key || !studs.length) {
                    alert('Pick a key and at least one student workbook.');
                    return;
                }

                // send exactly what's in the preview box
                const jsonBlob = new Blob([$('#jsonBox').value], { type: 'application/json' });
                const fd = new FormData();
                fd.append('key', key);
                fd.append('rubricJson', jsonBlob, 'rubric.json');
                for (const f of studs) fd.append('students', f);

                const res = await fetch('/api/grade', { method: 'POST', body: fd });
                const txt = await res.text();
                if (!res.ok) { alert(txt || `HTTP ${res.status}`); return; }   // << important
                showReport(txt);
            } catch (err) { console.error(err); alert('Grade failed'); }
        };



        // ---------- results viewer
        let lastReportRaw = '';
        $('#btnDownloadReport').onclick = () => { if (!lastReportRaw) { alert('Nothing to download yet.'); return; } download('report.json', lastReportRaw); };

        function keyForRule(r) {
            const t = (r.type || 'rule');

            // Charts
            if (t === 'chart' && r.chart) {
                const sh = (r.chart.sheet || '').trim();
                const nm = (r.chart.name_like || '').trim();
                if (nm) return `chart:${sh}${(sh && nm ? '/' : '')}${nm}`;

                // prefer type first
                const typ = (r.chart.type || '').trim().toLowerCase();
                if (sh && typ) return `chart:${sh}|type=${typ}`;

                // then title – include the value so it’s unique
                const title = (r.chart.title || '').trim().toLowerCase().replace(/\s+/g, ' ');
                if (sh && title) return `chart:${sh}|title=${title}`;

                // fallback to sheet
                if (sh) return `chart:${sh}`;
                return 'chart';
            }

            // Tables
            if (t === 'table' && r.table) {
                const sh = (r.table.sheet || '').trim();
                const nm = (r.table.name_like || r.table.tableNameLike || '').trim();
                if (nm) return `table:${sh}${(sh && nm ? '/' : '')}${nm}`;
                if (sh) return `table:${sh}`;
            }

            // Pivots
            if (t === 'pivot' && r.pivot) {
                const sh = (r.pivot.sheet || '').trim();
                const nm = (r.pivot.tableNameLike || '').trim();
                if (nm) return `pivot:${sh}${(sh && nm ? '/' : '')}${nm}`;
                if (sh) return `pivot:${sh}`;
            }

            const loc = (r.cell && r.cell.trim()) || (r.range && r.range.trim()) || '';
            return t + (loc ? (':' + loc) : '');
        }



        function buildSectionIndex() {
            const map = new Map();
            for (const [_sheetName, spec] of Object.entries(rubric.sheets || {})) {
                for (const rr of (spec.checks || [])) {
                    const k = keyForRule(rr);
                    if (k && rr.section) map.set(k, rr.section);
                }
            }
            return map;
        }


        function showReport(text) {
            let data;
            try { data = JSON.parse(text); } catch { alert('Bad JSON from server'); return; }
            lastReportRaw = text;

            // Normalize rows from several possible shapes
            let rows = [];
            if (Array.isArray(data)) rows = data;
            else if (Array.isArray(data.students)) rows = data.students;
            else if (Array.isArray(data.results)) rows = data.results;

            const body = document.getElementById('resultsBody');
            body.innerHTML = '';

            if (!rows.length) {
                const card = el('div', 'card', '<div class="muted">No results to show.</div>');
                body.appendChild(card);
                document.getElementById('resultsCard').style.display = '';
                return;
            }

            for (const r of rows) {
                // Support error rows: { student, error }
                if (r && r.error && (r.student || r.name)) {
                    const card = el('div', 'card');
                    const hdr = el('div', 'hstack');
                    hdr.innerHTML = `<h3>${escapeHtml(r.student ?? r.name ?? 'Student')}</h3>
                      <span class="tag fail">FAIL</span>
                      <span class="muted">${escapeHtml(String(r.error))}</span>`;
                    card.appendChild(hdr);
                    body.appendChild(card);
                    continue;
                }

                // Unwrap nested shape { student, grade }
                const isNested = r && typeof r.grade === 'object';
                const grade = isNested ? r.grade : r;

                const name = isNested ? (r.student ?? r.name ?? 'Student') : (grade.name ?? r.student ?? 'Student');
                const points = grade.total_points ?? grade.points ?? grade.Points ?? 0;
                const earned = grade.score_numeric ?? grade.earned ?? grade.Earned ?? 0;
                const details = grade.details ?? grade.Details ?? [];

                // Header: PASS only if 100%, else FAIL
                const pNum = Number(points), eNum = Number(earned);
                const headerPass = pNum > 0 && Math.abs(eNum - pNum) < 1e-9;
                const headerClass = headerPass ? 'pass' : 'fail';
                const headerStatus = headerPass ? 'PASS' : 'FAIL';

                const card = el('div', 'card');
                const hdr = el('div', 'hstack');
                hdr.innerHTML = `<h3>${escapeHtml(name)}</h3>
                    <span class="tag ${headerClass}">${headerStatus}</span>
                    <span class="muted">Score ${fmtNum(earned)}/${fmtNum(points)}</span>`;
                card.appendChild(hdr);

                // Table
                const tbl = el('table');
                const thead = el('thead');
                thead.innerHTML = `<tr>
                      <th>Check</th><th>Points</th><th>Earned</th><th>Result</th><th>Comment</th>
                      </tr>`;
                tbl.appendChild(thead);

                const tb = document.createElement('tbody');
                const sectionIndex = buildSectionIndex();
                const sectionTotals = new Map();

                // Section totals (for section header rows)
                for (const d of details) {
                    const sec = sectionIndex.get(String(d.check ?? d.rule ?? '')) || null;
                    if (!sec) continue;
                    const t = sectionTotals.get(sec) || { earned: 0, points: 0 };
                    t.points += (+d.points || 0);
                    t.earned += (+d.earned || 0);
                    sectionTotals.set(sec, t);
                }

                let currentSection = null;
                function maybeInsertSectionRow(sec) {
                    if (!sec || sec === currentSection) return;
                    currentSection = sec;
                    const t = sectionTotals.get(sec) || { earned: 0, points: 0 };
                    const tr = document.createElement('tr');
                    tr.className = 'section-row';
                    tr.innerHTML = `
                     <td colspan="5" style="font-weight:600; padding-top:10px;">
                     ${escapeHtml(sec)}
                     <span class="muted"> — ${fmtNum(t.earned)}/${fmtNum(t.points)}</span>
                     </td>`;
                    tb.appendChild(tr);
                }

                // Rows (PASS / PARTIAL / FAIL)
                for (const d of details) {
                    const ok = (d.passed ?? d.Passed);
                    const okBool = typeof ok === 'boolean' ? ok : (Number(d.earned) >= Number(d.points));
                    const partialBool = !okBool && Number(d.earned) > 0;

                    const sec = sectionIndex.get(String(d.check ?? d.rule ?? '')) || null;
                    maybeInsertSectionRow(sec);

                    const tr = document.createElement('tr');
                    tr.dataset.status = okBool ? 'pass' : (partialBool ? 'partial' : 'fail');

                    tr.innerHTML = `
            <td class="mono">${escapeHtml(d.check ?? d.rule ?? '')}</td>
            <td class="mono">${fmtNum(d.points)}</td>
            <td class="mono">${fmtNum(d.earned)}</td>
            <td>${okBool
                            ? '<span class="tag pass">PASS</span>'
                            : (partialBool
                                ? '<span class="tag partial">PARTIAL</span>'
                                : '<span class="tag fail">FAIL</span>')
                        }</td>
            <td>${escapeHtml(d.comment ?? d.message ?? '')}</td>`;
                    tb.appendChild(tr);
                }

                tbl.appendChild(tb);
                card.appendChild(tbl);
                body.appendChild(card);
            }

            // Respect “Show only misses” toggle
            const on = localStorage.getItem('onlyMisses') === '1' || document.getElementById('toggleOnlyMisses')?.checked;
            document.getElementById('resultsCard').classList.toggle('only-misses', !!on);

            document.getElementById('resultsCard').style.display = '';
            window.scrollTo({ top: document.getElementById('resultsCard').offsetTop - 10, behavior: 'smooth' });
        }




        const toggleOnlyMisses = document.getElementById('toggleOnlyMisses');
        if (toggleOnlyMisses) {
            const saved = localStorage.getItem('onlyMisses') === '1';
            toggleOnlyMisses.checked = saved;
            toggleOnlyMisses.addEventListener('change', () => {
                localStorage.setItem('onlyMisses', toggleOnlyMisses.checked ? '1' : '0');
                document.getElementById('resultsCard').classList.toggle('only-misses', toggleOnlyMisses.checked);
            });
        }

        function fmtNum(v) { return (v == null || isNaN(+v)) ? '' : (+v).toString(); }
        function escapeHtml(s) { return (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;'); }

        // boot
        render();
    </script>
</body>
</html>
